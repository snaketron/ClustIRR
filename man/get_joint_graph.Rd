\name{get_joint_graph}
\alias{get_joint_graph}
\title{Joins two graphs obtained from two or more \code{clust_irr} objects}
\usage{get_joint_graph(clust_irrs,
                cores = 1,
                custom_db = NULL,
                edit_dist = 0)}
\arguments{
\item{clust_irrs}{A list of at least two S4 objects generated with the 
function \code{cluster_irr}}
\item{cores}{integer, number of computer cores to use (default = 1)}
\item{custom_db}{data.frame, custom database with CDR3 sequences and their 
matching antigens. The structure of custom_db must be identical to data(vdjdb).
This is an optional input to annotate the clones. If \code{custom_db} is not 
provided, ClustIRR will use internal databases. See description below.}
\item{edit_dist}{integer, edit distance threshold. CDR3 sequences from the
graph will be matched with CDR3 sequences with known antigenic specificities 
(from a database). If their edit distance is lower or equal to \code{edit_dist},
then we have a match. Default \code{edit_dist} = 0, i.e. only identical CDR3s 
are matched.}
}
\value{
The main output of this function is an \code{igraph} object. This object
represents a joint graph of the individual graphs contained as elements 
in the input clust_irrs. The graph nodes and edges contain many attributes
which are described in the description section. 

One additional output is a data.frame in which rows are clones (vertices) 
in the joint graph.
}

\description{
As input we take at least two \code{clust_irr} objects generated by the 
function \code{cluster_irr}.

From each \code{clust_irr} object we generate a graph (with the function 
\code{get_graph}) in which the vertices represent clones, and undirected 
edges are drawn between a pair of vertices if the corresponding clones are 
locally and/or globally similar (see definitions of local/global clustering 
in the documentation of \code{cluster_irr}. 

Additionally, \code{get_joint_graph} performs the following operation 
between each pair of graphs:

First, it merges the vertices. If graphs \code{a} and \code{b} have \code{|a|}
and \code{|b|} vertices, then the joint graph has \code{|a|+|b|} vertices,
regardless of whether exactly the same clone (vertex) is found in both graphs.

Second, it performs global clustering between graph pairs. If two clones 
(graph vertices) have similar CDR3 sequences, then the vertices are connected 
by an edge. The same global clustering strategy (controls) are applied as the
ones used to build the individual clust_irr objects. If different clust_irr
objects are generated with different controls, then the graph merging 
algorithm will exit with an error.

The main output is an \code{igraph} object.

Third, we compare CDR3s from the graph against CDR3 sequences with known 
epitopes from these databases: VDJdb, McPAS-TCR and TCR3d. The comparison
is done based on the edit distance, where the parameter \code{edit_dist} 
controls the edit distance threshold (default=0). If the edit distance 
between two CDR3s is smaller than \code{edit_dist}, then the database 
information related to this CDR3 is transfered as vertex attribute to the 
corresponding vertex.

With the parameter \code{custom_db}, the user can provide additional 
databases with CDR3 sequences and their cognate antigens.
}

\examples{
# load package input data
data("CDR3ab")
s_1 <- data.frame(CDR3b = CDR3ab[1:100, "CDR3b"])
s_2 <- data.frame(CDR3b = CDR3ab[101:200, "CDR3b"])
r <- data.frame(CDR3b = CDR3ab[1:500, "CDR3b"])


# run 1st analysis -> clust_irr object
o_1 <- cluster_irr(s = s_1, r = r, ks = 4)

# run 2nd analysis -> clust_irr object
o_2 <- cluster_irr(s = s_2, r = r, ks = 4)

# join clust_irr objects in a list               
clust_irrs <- c(o_1, o_2)
names(clust_irrs) <- c("C1", "C2")

# get graph
g <- get_joint_graph(clust_irrs = clust_irrs)

names(g)
}
