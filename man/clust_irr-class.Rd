\name{clust_irr-class}
\docType{class}
\alias{clust_irr}
\alias{class:clust_irr}
\alias{clust_irr-class}

% Accessor methods:
\alias{get_clustirr_clust,clust_irr-method}
\alias{get_clustirr_inputs,clust_irr-method}
\alias{get_clustirr_clust}
\alias{get_clustirr_inputs}

\title{clust_irr class}

\arguments{
\item{clust}{list, contains clustering results for each TCR/BCR chain. The
results are stored in separate sub-list named appropriately (e.g. CDR3a, CDR3b, 
CDR3g, etc.)}
\item{inputs}{list, contains all user provided inputs}
}

\description{
Objects of the class \code{clust_irr} are generated by the function 
\code{cluster_irr}. These objects are used to store the clustering results 
in a structured way, such that they may be used as inputs of other ClustIRR 
functions (e.g. get_graph, plot_graph, etc.). 

Below we provide a detailed description of the slots of \code{clust_irr}.
\code{clust_irr} objects contain two sublists:

\itemize{
\item{clust} list, contains clustering results for each TCR/BCR chain. The
results are stored in separate sub-list named appropriately (e.g. CDR3a, 
CDR3b, CDR3g, etc.). In the following we who the typical structure of these 
lists:
\itemize{
    \item \code{local} - list, local clustering results
    \itemize{
        \item \code{m} - data.frame, motif enrichment results with columns:
        \itemize{
            \item \code{motif} - motif sequence
            \item \code{f_s} - observed motif counts in \code{s}
            \item \code{f_r} - observed motif counts in \code{r}
            \item \code{n_s} - number of all observed motifs in \code{s}
            \item \code{n_r} - number of all observed motifs in \code{r}
            \item \code{k} - motif length
            \item \code{ove} - mean observed/expected relative motif frequency
            \item \code{ove_ci_l95} - 95\% confidence intervals of ove (lower
            boundary)
            \item \code{ove_ci_h95} - 95\% confidence intervals of ove (upper
            boundary)
            \item \code{p_value} - p-value from Fisher's exact test
            \item \code{fdr} - false discovery rate, i.e. adjusted p-value by
            Benjamini & Hochberg correction
            \item \code{pass} - logical value indicating whether a motifs are
            enriched (\code{pass=TRUE}) given the user-defined thresholds in
            control}
            \item \code{lp} - data.frame, enriched motifs are linked to their
            original CDR3 sequences and shown as rows in the data.frame with
            the following columns:
            \itemize{
                \item \code{cdr3} - CDR3 amino acid sequence
                \item \code{cdr3_core} - core portion of the CDR3 sequence,
                obtained by trimming \code{trim_flank_aa} amino acids (user-
                defined parameter). If \code{trim_flank_aa} = 0, then 
                \code{cdr3} = \code{cdr3_core}
                \item \code{motif} - enriched motif from \code{cdr3_core}
            }
        }
        \item \code{global} - data.frame, global clustering results. Pairs of
        globally similar CDR3s are shown in each row (analogous to \code{lp}).
        If \code{global_smart}=FALSE in the control, then global clustering is 
        done based on Hamming distances and the remaining columns of this 
        data.frame are not important. Else, if \code{global_smart}=FALSE, then
        the remainig columns are relevant, i.e. global similarity scores are 
        shown for the complete CDR3 sequence pairs (column \code{weight}) or 
        their core (trimmed) CDR3 sequence part (column \code{cweight}). The 
        column \code{max_len} stores the the maximum length in each pair of 
        CDR3 sequences, and is used to normalize the scores \code{weight} and 
        \code{cweight}: the normalized scores are shown in the columns 
        \code{nweight} and \code{ncweight}.
    }
\item{inputs:}list, contains all user provided inputs
}
}

\section{Accessors}{
To access the slots of \code{clust_irr} object we have two accessor 
functions. In the description below, \code{x} is a \code{clust_irr} 
object.

\describe{
\item{get_clustirr_clust}{
\code{get_clustirr_clust(x)}:
Extract the clustering results (slot clust)
}
\item{get_clustirr_inputs}{
\code{get_clustirr_inputs(x)}:
Extract the processed inputs (slot inputs)
}
}
}

\value{
The output is an S4 object of class \code{clust_irr}
}

\examples{
# inputs
data("CDR3ab")
s <- data.frame(CDR3b = CDR3ab[1:1000, "CDR3b"])
r <- data.frame(CDR3b = CDR3ab[1:5000, "CDR3b"])

# controls: auxiliary inputs
control <- list(global_smart = TRUE,
                global_max_hdist = 1,
                global_min_identity = 0.7,
                local_max_fdr = 0.05,
                local_min_o = 1,
                trim_flank_aa = 3,
                low_mem = FALSE)

# clust_irr S4 object generated by function cluster_irr
clust_irr_output <- cluster_irr(s = s, r = r,ks = 4,cores = 1,control = control)
 
# clust_irr S4 object generated 'manually' from the individual results
new_clust_irr <- new("clust_irr", 
                     clust = slot(object = clust_irr_output, name = "clust"),
                     inputs = slot(object = clust_irr_output, name = "inputs"))

# we should get identical outputs
identical(x = new_clust_irr, y = clust_irr_output)
}
