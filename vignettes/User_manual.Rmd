---
title: "Introduction to ClustIRR"
author: "Kai Wollek and Simo Kitanovski"
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{Introduction to ClustIRR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r}
library(knitr)
library(ClustIRR)
library(igraph)
library(visNetwork)
library(ggplot2)
library(ggrepel)
```

# Introduction
Adaptive immunity relies on diverse immune receptor repertoires (IRRs: B- and 
T-cell receptor repertoires) to protect the host against genetically diverse 
and rapidly evolving pathogens, such as viruses, bacteria, and cancers. The 
sequence diversity of B- and T-cell receptors (BCRs and TCRs) originates, in 
part, from V(D)J recombination, a process in which different germline-encoded 
genes are joined to form unique immune receptors. As a result, practically 
every newly formed naive mature T and B cell is equipped with a distinct 
immune receptor (IR), enabling them to recognize unique sets of antigens.

B cells bind antigens directly through the complementarity-determining regions 
(CDRs) of their BCRs, while T cells recognize antigenic peptides presented by 
major histocompatibility complex (MHC) molecules via the CDRs of their TCRs. 
Antigen recognition can lead to B/T cell activation, causing these cells to 
rapidly proliferate and form antigen-specific clones capable of mounting an 
effective immune response.

Recent studies have shown that sequence similarity between TCRs often 
indicates shared antigen specificity. Therefore, by clustering TCR sequences 
from high-throughput sequencing (HT-seq) data, we can identify groups of 
TCRs with shared antigen specificity. This information is crucial for the 
development of cancer immunotherapies, vaccines, and antiviral drugs.

This vignette introduces `r Biocpkg("ClustIRR")`, a computational method 
for clustering IRRs.

# Installation
`r Biocpkg("ClustIRR")` is freely available as part of Bioconductor, filling
the gap that currently exists in terms of software for quantitative analysis 
of IRRs. 

To install `r Biocpkg("ClustIRR")` please start R and enter:

```{r, eval=FALSE}
if(!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
BiocManager::install("ClustIRR")
```

# ClustIRR algorithm
The algorithm of `r Biocpkg("ClustIRR")` performs 1. clustering of IRR 
sequences to find groups of receptors with similar specificity; and employs
a Bayesian model to quantify differential community occupancy between IRRs.

```{r graphic, echo = FALSE, fig.align="left", out.width='90%'}
knitr::include_graphics("../inst/extdata/logo.png")
```

## Input

The main input of `r Biocpkg("ClustIRR")` is an IRR (`s`).

`s`should be provided as data.frame. The rows in the data.frame correspond 
to **clones** (clone = group of cells derived from a common parent cell by 
clonal expansion). We use the following data from each clone:

  * **amino acid sequence/s** of the complementarity determining regions 3 
  from one or both chains (e.g. CDR3$\alpha$ and CDR3$\beta$ from $\alpha\beta$ 
  TCRs).
  * **size** = frequency of cells that belong to the clone
  
Let's have a look at an example data set which we will use as input:

```{r}
data("CDR3ab", package = "ClustIRR")
```

```{r}
# get 500 CDR3a and CDR3b pairs from the data -> s
s <- data.frame(CDR3a = CDR3ab$CDR3a[1:500],
                CDR3b = CDR3ab$CDR3b[1:500], 
                clone_size=1,
                sample = "A")
```


```{r}
str(s)
```

## **Step 1.** TCR clustering with `cluster_irr`
In a given IRR, we assume that two CDR3 having identical sequences will 
recognize the same sets of antigens. Meanwhile, we also know that similar 
CDR3 sequences (e.g., CDR3 sequences which differ by only one amino acid) 
may also have common specificity. `r Biocpkg("ClustIRR")` employs clustering 
to find groups of CDR3s which are **globally similar** (based on the complete 
CDR3 sequences). 

For this we employs one of two strategies.

*Strategy A:* default

Given $N$ CDR3 sequences, `r Biocpkg("ClustIRR")` performs $n^2$ pairwise 
Needleman-Wunsch alignments. For pair $i$, it computes a BLOSUM62 similarity 
score $b_i$. To ensure that the similarity scores are comparable across pairs 
of CDR3s with different lengths, we divide $b_i$ with $l_i$, the maximum 
length of the longer CDR3 sequence in $i$: 

$b'_i = \dfrac{b_i}{l_i} = \dfrac{b_i}{\max(m_i, k_i)}$

with $m_i$ and $k_i$ as the lengths of the two CDR3 sequences in pair $i$; 
and $b'_i$ as the normalized similarity score.

This strategy is computationally very expensive!

The Needleman-Wunsch algorithm has a time complexity $O(mk)$. Empirically 
we know that $m \approx k$, and the typical values of $m$ and $k$ range 
between 6 and 20 (mean = 13). This operation has to be performed $n^2$ 
times. Therefore, the time complexity of this procedure is approximately 
$O(m^2n^2)$.

For large IRRs with $n>10^6$, which is common nowadays, this algorithm 
requires significant computational resources. To mitigate this challenge, 
we only consider pairs of CDR3 sequences with sequence identity $\geq$ 70%. 
This threshold may be modified by the user (by modifying the input parameter 
`control$gmi`). For the remaining pairs we consider $b'_i=0$.

*Strategy B:* if `control$global_hamming = TRUE`

Alternatively, `r Biocpkg("ClustIRR")` quantifies the dissimilarity between 
pairs of CDR3 sequences using Hamming distances. Two CDR3 sequences with 
Hamming distance $\leq x$ are considered globally similar, where $x$ is an 
user-defined threshold (input `control$global_max_hdist`, default = 1). 

This is a computationally and conceptually simple strategy, which also has 
drawbacks:

1. CDR3 sequences with different lengths are by definition dissimilar
2. the properties of the replaced amino acids are not considered by the 
Hamming distance

*Output*: global TCR clustering is done with the function `clust_irr` which 
returns an S4 object of class `clust_irr`. The object contains two sublists 
(slots):

1. chain-specific clustering results: tables and lists
2. processed inputs: processed form of the input data (`s`) and parameters


## **Step 2.** building a graph with `get_graph` or `get_joint_graph`
Next, `r Biocpkg("ClustIRR")` builds a graph. If we analyze one IRR, then
we may employ the function `get_graph`, which converts the `clust_irr` object
into an `igraph` object. Meanwhile, if we are analyzing two ore more IRRs, 
then we can use the function `get_joint_graph` to generate a joint `igraph`
object.

The graphs have *nodes* and *weighted edges*:

  * nodes: clones from each IRR. Each clone attribute (clone size, CDR3 
  sequences, etc) is provided as node attribute
  * edges: connections between nodes (clones) within each IRR (computed in 
  step 1.), and between IRRs (computed by get_joint_graph if multiple IRRs 
  are provided), with edge weights set according to the normalized similarity 
  score $b'_i$
  
**Output**: the output of `get_graph` or `get_joint_graph`is an `igraph` 
object. This allows us to use `igraph` functions to evaluate different 
properties of the graph, such as, the distribution of edge weights, or the
node degree distribution.

**Important note**: `r Biocpkg("ClustIRR")` provides the function 
`get_graph_dummy`, which allows the user to skip  step. 1 of the algorithm.
The inputs of this function is IRR `s` (same as before) and a data frame 
containing the (symbolic) edge list. This enables seamless integration of 
`r Biocpkg("ClustIRR")` with computational pipelines that employ other IRR 
clustering approaches, such as gliph[^1], TCRdist3[^2], GIANA[^3], etc.


## **Step 3.** community detection


## **Step 4.** differential community occypancy


## **Step 5.** output visualization and annotation




# Case study 1: analysis of **one** TCR repertoire
In this example, we will investigate one $\alpha\beta$ TCR repertoire with
$n=500$ clones, created from the example dataset `CDR3ab`.

```{r}
# get CDR3ab example data
data("CDR3ab", package = "ClustIRR")
```

```{r}
# create a repertoire with 500 alpha-beta CDR3 pairs
s <- data.frame(CDR3a = CDR3ab$CDR3a[1:500], 
                CDR3b = CDR3ab$CDR3b[1:500],
                clone_size = 1,
                sample = "A")
```

## **Step 1.** `cluster_irr` performs global clustering of TCRs

```{r}
# perform clustirr analysis
c <- cluster_irr(s = s, control = list(gmi = 0.7))
```

In the next, we show the global clustering results for CDR3a and CDR3b 
sequences (separately). Each row is a pair of CDR3 sequences from the 
repertoire. For each pair we have the following metrics:

  * `weight`: BLOSUM62 score of the **complete** CDR3 alignment
  * `cweight`: BLOSUM62 score of CDR3 cores
  * `max_len`: length of the longer CDR3 sequence in the pair
  * `nweight`, `ncweight`: normalized `weight` and `cweight` by `max_len`
  
The results for CDR3a:

```{r}
kable(head(c@clust$CDR3a, n = 15), digits = 2)
```


... the same table as CDR3b sequence pairs:

```{r}
kable(head(c@clust$CDR3a, n = 15), digits = 2)
```


## **Step 2.** `get_graph` and `plot_graph` visualize specificity structure
We can also plot a graph of the global specificity structure in this TCR 
repertoire. 

**Warning! The graph is complex!**

```{r}
g <- get_graph(clust_irr = c)
```

```{r}
plot_graph(g, as_visnet = TRUE)
```


The graph is an `igraph` object. We can use the `igraph` functions to inspect 
different properties of the graph, such as, the distribution of edge weights 
(shown below). Notice, that the edge weights vary drastically between the 
edges.

```{r, fig.width=6, fig.height=4.5}
par(mfrow = c(2,2))
hist(E(g$graph)$weight, main = "weight")
hist(E(g$graph)$nweight, main = "nweight")
hist(E(g$graph)$cweight, main = "cweight")
hist(E(g$graph)$ncweight, main = "ncweight")
```

## **Step 3.** `detect_communities` identifies graph communities
Are there densely connected sets of nodes (=communities) in this graph? 

To answer this question we can use graph-based community detection (GCD) 
algorithms, such as Leiden or Louvain. As input for GCD we will use the 
`ncweight` (default) between CDR3a, CDR3b or both CDR3a and CDR3b. 

```{r}
gcd <- detect_communities(graph = g$graph, 
                          weight_type = "ncweight",
                          algorithm = "leiden",
                          resolution = 1,
                          chains = c("CDR3a", "CDR3b"))
```


The `community_occupancy_matrix` object is a count matrix with communities 
as rows and IRRs (here 1 sample) as columns. The counts are number of cells 
(sum of `clone_size` of nodes in community) in each community and sample.

```{r}
community_occupancy_matrix <- gcd$community_occupancy_matrix
head(community_occupancy_matrix)
```

Most communities are made up of one cell, while some contain 2 or 3 cells. 

```{r}
table(community_occupancy_matrix)
```

Lets look at the clones in these communities. For this we can access the 
data.frame `node_summary`.

```{r}
node_summary <- gcd$node_summary
kable(head(node_summary))
```

Which nodes are found in communities with at least 4 cells?

```{r}
# interesting coms
coms <- which(community_occupancy_matrix>=4)
```


```{r}
n <- node_summary[node_summary$community %in% coms,
                  c("sample", "community", "clone_size", "CDR3b", "CDR3a")]
n <- n[order(n$community),]
kable(n)
```

What is the contribution of CDR3a and CDR3b to the formation of 
these communities? To answer this question we can access the object 
`community_summary`.

```{r}
community_summary <- gcd$community_summary
```

In two communities CDR3b appears to have high contribution, and in one CDR3a. 
Please compare these results with the data.frame `node_summary` (shown above).

```{r, fig.width=3, fig.height=3}
n <- community_summary[community_summary$community %in% coms, 
                       c("community", "w_CDR3a_mean", "w_CDR3b_mean", 
                         "w_CDR3a_CDR3b_mean")]

ggplot(data = n)+
  geom_point(aes(x = w_CDR3a_mean, y = w_CDR3b_mean))+
  geom_text_repel(aes(x = w_CDR3a_mean, y = w_CDR3b_mean, label = community),
                  min.segment.length = 0, col = "darkgray")+
  xlab(label = "CDR3a ncweight")+
  ylab(label = "CDR3b ncweight")+
  theme_bw(base_size = 10)
```

```{r, echo=FALSE, include=FALSE}
rm(t, ks, coms, cdr3_trimmed, cdr3, s, node_summary, n, 
   gcd, g, c, community_summary, community_occupancy_matrix)
```



# Case study 2: analysis of **two** TCR repertoires
Imagine that we have two samples from one patient: before (a) and after (b) 
treatment. 


```{r}
# repertoire size
n <- 300

# before
a <- data.frame(CDR3a = CDR3ab$CDR3a[1:n], 
                CDR3b = CDR3ab$CDR3b[1:n],
                sample = "a")
# after
b <- data.frame(CDR3a = CDR3ab$CDR3a[1:n], 
                CDR3b = CDR3ab$CDR3b[1:n],
                sample = "b")
```

```{r}
get_clonal_expansion <- function(n, p_expanded) {
  s <- sample(x = c(0, 1), size = n, prob = c(1-p_expanded, 
                                              p_expanded), replace = T)
  y <- vapply(X = s, FUN.VALUE = numeric(1), FUN = function(x) {
    if(x == 0) {
      return(rpois(n = 1, lambda = 0.5))
    }
    return(rpois(n = 1, lambda = 50))
  })
  return(y)
}
```

```{r}
# simulate expansion of specific communities
set.seed(1243)
clone_size <- rpois(n = n, lambda = 3)+1
expansion_factor <- rbind(get_clonal_expansion(n = n, p_expanded = 0),
                          get_clonal_expansion(n = n, p_expanded = 0.02))

a$clone_size <- clone_size+expansion_factor[1,]
b$clone_size <- clone_size+expansion_factor[2,]
```


## **Step 1.** `cluster_irr` does global clustering of TCRs in each repertoire

```{r}
# run cluster_irr on each IRR and join the results
clust_irrs <- c(cluster_irr(s = a), cluster_irr(s = b))
```


## **Step 2.** `get_graph` and `plot_graph` visualize specificity structures
We can also plot a graph of the global specificity structure in TCR repertoire 
a and b. 

```{r, fig.width=6, fig.height=6}
# beta & alpha chain
g <- get_joint_graph(clust_irrs = clust_irrs, cores = 1)
```


```{r, fig.width=6, fig.height=6}
plot_graph(g = g, as_visnet = TRUE, node_opacity = 0.8)
```



## **Step 3.** `detect_communities` identifies communities in the graph 
Are there densely connected sets of nodes (=communities) in this graph? 

To answer this question we can use graph-based community detection (GCD) 
algorithms, such as Leiden or Louvain. As input for GCD we can use `nweight` 
or `ncweight` (default) between CDR3a, CDR3b or both CDR3a and CDR3b. 

```{r}
gcd <- detect_communities(graph = g$graph,
                          weight_type = "ncweight",
                          algorithm = "leiden",
                          resolution = 1,
                          chains = c("CDR3a", "CDR3b"))
```


How many cells from IRR a (x-axis) and IRR b (y-axis) are there in each 
community (point)?

```{r, fig.width=4, fig.height=4}
ggplot(data = gcd$community_summary)+
  geom_point(aes(x = cells_a, y = cells_b))+
  theme_bw(base_size = 10)
```


The number of cells in each IRR and community are stored as cells in the 
matrix `community_occupancy_matrix`. Rows are communities, and columns 
are IRRs

```{r}
community_occupancy_matrix <- gcd$community_occupancy_matrix
head(community_occupancy_matrix)
```


## **Step 4.** `dco` performs differential community occupancy (DCO) analysis
Do we see growing or shrinking communities between the IRRs? We employ a
Bayesian model to quantify whether communities grow ($\beta$ > 0) or shrink 
($\beta$ < 0)

```{r}
d <- dco(community_occupancy_matrix = community_occupancy_matrix,
         mcmc_control = list(mcmc_warmup = 500,
                             mcmc_iter = 1500,
                             mcmc_chains = 3,
                             mcmc_cores = 1,
                             mcmc_algorithm = "NUTS",
                             adapt_delta = 0.9,
                             max_treedepth = 10))
```


## **Step 5.** posterior predictive check

```{r, fig.width=6, fig.height=2.5}
ggplot(data = d$posterior_summary$y_hat)+
  facet_wrap(facets = ~sample, nrow = 1, scales = "free")+
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", col = "gray")+
  geom_errorbar(aes(x = y_obs, y = mean, ymin = X2.5., ymax = X97.5.),
                col = "darkgray", width=0)+
  geom_point(aes(x = y_obs, y = mean), size = 0.8)+
  xlab(label = "observed y")+
  ylab(label = "predicted y (and 95% HDI)")+
  theme_bw(base_size = 10)
```


## **Step 6.** $\beta$ parameters

```{r, fig.width=6, fig.height=4}
beta <- d$posterior_summary$beta
beta$interesting <- ifelse(test = beta$X2.5.<=0 & beta$X97.5.>=0,
                           yes = "-", no = "+")
ggplot(data = beta)+
  geom_errorbar(aes(x = community, y = mean, ymin = X2.5., ymax = X97.5.,
                    col = interesting), width =0)+
  geom_point(aes(x = community, y = mean), size = 0.5)+
  theme_bw(base_size = 10)+
  theme(legend.position = "none")+
  scale_color_manual(values = c("darkgray", "black"))+
  ylab(label = expression(beta))
```

Distribution of mean $\beta$s

```{r, fig.width=4, fig.height=3}
ggplot(data = d$posterior_summary$beta)+
  geom_histogram(aes(mean), bins = 100)+
  xlab(label = expression(beta))+
  theme_bw(base_size = 10)
```


```{r session_info}
utils::sessionInfo()
```


[^1]: Glanville, Jacob, et al. "Identifying specificity groups in the T cell 
receptor repertoire." Nature 547.7661 (2017): 94-98.
[^2]: Mayer-Blackwell, Koshlan, et al. "TCR meta-clonotypes for biomarker 
discovery with tcrdist3 enabled identification of public, HLA-restricted 
clusters of SARS-CoV-2 TCRs." Elife 10 (2021): e68605.
[^3]: Zhang, Hongyi, Xiaowei Zhan, and Bo Li. "GIANA allows computationally-
efficient TCR clustering and multi-disease repertoire classification by 
isometric transformation." Nature communications 12.1 (2021): 4699.
