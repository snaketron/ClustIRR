---
title: "Introduction to ClustIRR"
author: "Kai Wollek and Simo Kitanovski"
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{Introduction to ClustIRR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r}
library(knitr)
library(ClustIRR)
library(rstan)
library(visNetwork)
library(ggplot2)
library(ggrepel)
```

# Introduction
Adaptive immunity relies on diverse immune receptor repertoires (IRRs: B- and 
T-cell receptor repertoires) to protect the host against genetically diverse 
and rapidly evolving pathogens, such as viruses, bacteria, and cancers. The 
sequence diversity of B- and T-cell receptors (BCRs and TCRs) originates, in 
part, from V(D)J recombination, a process in which different germline-encoded 
genes are joined to form unique immune receptors. As a result, practically 
every newly formed naive mature T and B cell is equipped with a distinct 
immune receptor (IR), enabling them to recognize unique sets of antigens.

B cells bind antigens directly through the complementarity-determining regions 
(CDRs) of their BCRs, while T cells recognize antigenic peptides presented by 
major histocompatibility complex (MHC) molecules via the CDRs of their TCRs. 
Antigen recognition can lead to B/T cell activation, causing these cells to 
rapidly proliferate and form antigen-specific clones capable of mounting an 
effective immune response.

Recent studies have shown that sequence similarity between TCRs often 
indicates shared antigen specificity. Therefore, by clustering TCR sequences 
from high-throughput sequencing (HT-seq) data, we can identify groups of 
TCRs with shared antigen specificity. This information is crucial for the 
development of cancer immunotherapies, vaccines, and antiviral drugs.

This vignette introduces `r Biocpkg("ClustIRR")`, a computational method 
for clustering IRRs.

# Installation
`r Biocpkg("ClustIRR")` is freely available as part of Bioconductor, filling
the gap that currently exists in terms of software for quantitative analysis 
of IRRs. 

To install `r Biocpkg("ClustIRR")` please start R and enter:

```{r, eval=FALSE}
if(!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}
BiocManager::install("ClustIRR")
```

# ClustIRR algorithm
The algorithm of `r Biocpkg("ClustIRR")` performs 1. clustering of IRR 
sequences to find groups of receptors with similar specificity; and employs
a Bayesian model to quantify differential community occupancy between IRRs.

```{r graphic, echo = FALSE, fig.align="left", out.width='90%'}
knitr::include_graphics("../inst/extdata/logo.png")
```

## Input

The main input of `r Biocpkg("ClustIRR")` is one IRR (`s`), or two IRRs (`s`
and `r`).

* `s`: IRR under investigation (e.g. IRR after treatment)
* `r`: control IRR (e.g. IRR before treatment)

`s` and `r` should be provided as data.frames with matching columns. The rows 
in the data.frames correspond to **clones** (clone = group of cells derived 
from a common parent cell by clonal expansion). We use the following data 
from each clone:

  * **amino acid sequence/s** of the complementarity determining regions 3 
  from one or both chains (e.g. CDR3$\alpha$ and CDR3$\beta$ from $\alpha\beta$ 
  TCRs).
  * **size** = frequency of cells that belong to the clone
  
Let's have a look at an example data set which we will use as input:

```{r}
data("CDR3ab", package = "ClustIRR")
```

```{r}
# get 500 CDR3a and CDR3b pairs from the data -> s
s <- data.frame(CDR3a = CDR3ab$CDR3a[1:500],
                CDR3b = CDR3ab$CDR3b[1:500], 
                clone_size=1)

# get 500 CDR3a and CDR3b pairs from the data -> r
r <- data.frame(CDR3a = CDR3ab$CDR3a[501:1000],
                CDR3b = CDR3ab$CDR3b[501:1000], 
                clone_size=1)
```


```{r}
str(s)
```


```{r}
str(r)
```



## Clustering

`r Biocpkg("ClustIRR")` employs **global** and **local** clustering strategies.

The rationale behind these two clustering strategies is the following: two 
identical CDR3 sequences have the same specificity. Similar CDR3 sequences 
(e.g., CDR3 sequences that differ by only one amino acid) may also have the
same specificity. Global clustering is meant to find pairs of CDR3s that are
globally (based on the complete CDR3 sequences) similar. 

We also know that two CDR3s with significantly different sequences may still 
recognize the same peptide[^1] if they share a motif in their core regions 
(e.g., identical 4-mer). Such "useful" motifs may be enriched in `s`  but not 
in `r`, and local clustering aims to identify them.

While global clustering is always employed by `r Biocpkg("ClustIRR")`, local
clustering is only used when the user provides as input both `s` and `r`.


### Global clustering
For global clustering, `r Biocpkg("ClustIRR")` employs one of two strategies.

*Strategy 1:* default

Given $N$ CDR3 sequences, `r Biocpkg("ClustIRR")` performs $n^2$ pairwise 
Needleman-Wunsch alignments. For pair $i$, it computes a BLOSUM62 similarity 
score $b_i$. To ensure that the similarity scores are comparable across pairs 
of CDR3s with different lengths, we divide $b_i$ with $l_i$, the maximum length 
of the longer CDR3 sequence in $i$: 

$b'_i = \dfrac{b_i}{l_i} = \dfrac{b_i}{\max(m_i, k_i)}$

with $m_i$ and $k_i$ as the lengths of the two CDR3 sequences in pair $i$; and 
$b'_i$ as the normalized similarity score.

This strategy is computationally very expensive!

The Needleman-Wunsch algorithm has a time complexity $O(mk)$. Empirically we
know that $m \approx k$, and the typical values of $m$ and $k$ range between 
6 and 20 (mean = 13). This operation has to be performed $n^2$ times. Therefore,
the time complexity of this procedure is approximately $O(m^2n^2)$.

For large IRRs with $n>10^6$, which is common nowadays, this algorithm 
requires significant computational resources. To mitigate this challenge, 
we only consider pairs of CDR3 sequences with sequence identity $\geq$ 70%. 
This threshold may be modified by the user (by modifying the input parameter 
`control$global_min_identity`). For the remaining pairs we consider $b'_i=0$.

*Strategy 2:* if `control$global_hamming = TRUE`

Alternatively, `r Biocpkg("ClustIRR")` quantifies the dissimilarity between 
pairs of CDR3 sequences using Hamming distances. Two CDR3 sequences with 
Hamming distance $\leq x$ are considered globally similar, where $x$ is an 
user-defined threshold (input `control$global_max_hdist`, default = 1). 

This is a computationally and conceptually simple strategy, which also has 
drawbacks:

1. CDR3 sequences with different lengths are by definition dissimilar
2. the properties of the replaced amino acids are not considered by the 
Hamming distance

### Local clustering

CDR3 sequences are segmented into overlapping **motifs** ($k$-mers), where $k$ 
is specified by setting the input `ks`. 

Example of segmenting CDR3 sequence into 4-mers:

```{r}
cdr3 <- "CASSTTTGTGELFF"
ks <- 4
colnames(stringdist::qgrams(cdr3, q = ks))
```

Empirically we know that $k$-mers in the **core** of a CDR3 are more likely 
to establish contact with an antigenic peptide than $k$-mers in the flanks 
of the CDR3. Hence, the user is encouraged to remove a few amino acids from 
the flanks of each CDR3 sequence. This can be done by changing the control
input from `control$trim_flank_aa,` e.g.:
  
  * `control$trim_flank_aa = 0`: no trimming
  * `control$trim_flank_aa = 3`: trim three amino acids from both flanks 
  of the CDR3 sequence (default)

In the next code block we trim CDR3 flanks and segment the core of the CDR3 
sequence `CASSTTTGTGELFF` into 4-mers. The result are five overlapping motifs:

```{r}
t <- 3
cdr3_trimmed <- substr(x = cdr3, start = t + 1, stop = nchar(cdr3) - t)
colnames(stringdist::qgrams(cdr3_trimmed, q = ks))
```
 

A motif is considered statistically enriched in `s` compared to `r` if the 
following (user-defined) criteria are satisfied:

1. `control$local_min_o`: minimum motif frequency in `s`
      
2. `control$local_max_fdr`: maximum false discovery rate (FDR). Corrected 
    p-value, computed by a one-sided Fisher's exact test (hypergeometric 
    test).

## Output

The main function in `r Biocpkg("ClustIRR")` is `cluster_irr`. This function 
returns an S4 object of class `clust_irr`. The object contains two sublists 
(slots):

1. clustering results: tables and lists
2. processed inputs: processed form of the input data (`s`) and parameters

We will describe the inputs, outputs, and the algorithm of 
`r Biocpkg("ClustIRR")` with the help of the following case studies. 


# Case study 1: analysis of **one** TCR repertoire
In this example, we will investigate one $\alpha\beta$ TCR repertoire with
$n=1000$ clones, created from the example dataset `CDR3ab`.

```{r}
# get CDR3ab example data
data("CDR3ab", package = "ClustIRR")
```

```{r}
# create a repertoire with 1000 alpha-beta CDR3 pairs
s <- data.frame(CDR3a = CDR3ab$CDR3a[1:1000], 
                CDR3b = CDR3ab$CDR3b[1:1000])
```

## **Step 1.** `cluster_irr` performs global clustering of TCRs

```{r}
# perform clustirr analysis
c <- cluster_irr(s = s, control = list(global_min_identity = 0.7))
```

In the next, we show the global clustering results for CDR3a and CDR3b 
sequences (separately). Each row is a pair of CDR3 sequences from the 
repertoire. For each pair we have the following metrics:

  * `weight`: BLOSUM62 score of the **complete** CDR3 alignment
  * `cweight`: BLOSUM62 score of CDR3 cores
  * `max_len`: length of the longer CDR3 sequence in the pair
  * `nweight`, `ncweight`: normalized `weight` and `cweight` by `max_len`
  
The results for CDR3a:

```{r}
kable(head(c@clust$CDR3a$global, n = 10), digits = 2)
```


... the same table as CDR3b sequence pairs:

```{r}
kable(head(c@clust$CDR3a$global, n = 10), digits = 2)
```

## **Step 2.** `get_graph` and `plot_graph` visualize specificity structure
We can also plot a graph of the global specificity structure in this TCR 
repertoire. 

Warning! The graph is complex! 

```{r}
g <- get_graph(clust_irr = c, sample_id = "S1")
```

```{r}
plot_graph(g, as_visnet = TRUE)
```

## **Step 3.** `detect_communities` identifies graph communities
Are there densely connected sets of nodes (=communities) in this graph? 

To answer this question we can use graph-based community detection (GCD) 
algorithms, such as Leiden or Louvain. As input for GCD we can use `nweight` 
or `ncweight` (default) between CDR3a, CDR3b or both CDR3a and CDR3b. 

```{r}
gcd <- detect_communities(graph = g$graph, 
                          weight_type = "ncweight",
                          algorithm = "leiden",
                          resolution = 1,
                          chains = c("CDR3a", "CDR3b"))
```


The `community_matrix` object is a count matrix with communities as rows 
and IRRs (here 1 sample) as columns. The counts are number of cells (sum 
of `clone_size` of nodes in community) in each community and sample.

```{r}
community_matrix <- gcd$community_matrix
head(community_matrix)
```

Most communities are made up of one cell, while some contain 2 or 3 cells. 

```{r}
table(community_matrix)
```

Lets look at the clones in these communities. For this we can access the 
data.frame `node_summary`.

```{r}
node_summary <- gcd$node_summary
kable(head(node_summary))
```

Which nodes are found in communities with at least 3 cells?

```{r}
# interesting coms
coms <- which(community_matrix>=3)
```


```{r}
n <- node_summary[node_summary$community %in% coms,
                  c("sample", "community", "clone_size", "CDR3b", "CDR3a")]
n <- n[order(n$community),]
kable(n)
```

What is the contribution of CDR3a and CDR3b to the formation of 
these communities? To answer this question we can access the object 
`community_summary`.

```{r}
community_summary <- gcd$community_summary
```

In two communities CDR3b appears to have high contribution, and in one CDR3a. 
Please compare these results with the data.frame `node_summary` (shown above).

```{r, fig.width=3, fig.height=3}
n <- community_summary[community_summary$community %in% coms, 
                       c("community", "w_CDR3a_mean", "w_CDR3b_mean", 
                         "w_CDR3a_CDR3b_mean")]

ggplot(data = n)+
  geom_point(aes(x = w_CDR3a_mean, y = w_CDR3b_mean))+
  geom_text_repel(aes(x = w_CDR3a_mean, y = w_CDR3b_mean, label = community),
                  min.segment.length = 0)+
  xlab(label = "CDR3a ncweight")+
  ylab(label = "CDR3b ncweight")+
  theme_bw(base_size = 10)
```

```{r, echo=FALSE, include=FALSE}
rm(t, ks, coms, cdr3_trimmed, cdr3, s, r, node_summary, n, 
   gcd, g, c, community_summary, community_matrix)
```



# Case study 2: analysis of **two** TCR repertoires
Imagine that we have two samples from one patient: before (a) and after (b) 
treatment. 


```{r}
# repertoire size
n <- 300

# before
a <- data.frame(CDR3a = CDR3ab$CDR3a[1:n], CDR3b = CDR3ab$CDR3b[1:n])
# after
b <- data.frame(CDR3a = CDR3ab$CDR3a[1:n], CDR3b = CDR3ab$CDR3b[1:n])
```

```{r}
get_clonal_expansion <- function(n, p_expanded) {
  s <- sample(x = c(0, 1), size = n, prob = c(1-p_expanded, 
                                              p_expanded), replace = T)
  y <- vapply(X = s, FUN.VALUE = numeric(1), FUN = function(x) {
    if(x == 0) {
      return(rpois(n = 1, lambda = 0.5))
    }
    return(rpois(n = 1, lambda = 50))
  })
  return(y)
}
```



```{r}
# simulate expansion of specific communities
set.seed(1243)
clone_size <- rpois(n = n, lambda = 3)+1
expansion_factor <- rbind(get_clonal_expansion(n = n, p_expanded = 0),
                          get_clonal_expansion(n = n, p_expanded = 0.02))

a$clone_size <- clone_size+expansion_factor[1,]
b$clone_size <- clone_size+expansion_factor[2,]
```


## **Step 1.** `cluster_irr` does global clustering of TCRs in each repertoire

```{r}
# per
clust_irrs <- c(cluster_irr(s = a), cluster_irr(s = b))
names(clust_irrs) <- c("a", "b")
```


## **Step 2.** `get_graph` and `plot_graph` visualize specificity structures
We can also plot a graph of the global specificity structure in TCR repertoire 
a and b. 

```{r, fig.width=6, fig.height=6}
# beta & alpha chain
g <- get_joint_graph(clust_irrs = clust_irrs, cores = 1)
```


```{r, fig.width=6, fig.height=6}
plot_graph(g = g, as_visnet = TRUE, node_opacity = 0.8)
```


## **Step 3.** `detect_communities` identifies communities in the graph 
Are there densely connected sets of nodes (=communities) in this graph? 

To answer this question we can use graph-based community detection (GCD) 
algorithms, such as Leiden or Louvain. As input for GCD we can use `nweight` 
or `ncweight` (default) between CDR3a, CDR3b or both CDR3a and CDR3b. 

```{r}
gcd <- detect_communities(graph = g$graph,
                          weight_type = "ncweight",
                          algorithm = "leiden",
                          resolution = 1,
                          chains = c("CDR3a", "CDR3b"))
```


```{r, fig.width=4, fig.height=4}
ggplot(data = gcd$community_summary)+
  geom_point(aes(x = cells_a, y = cells_b))+
  theme_bw(base_size = 10)
```


```{r}
community_matrix <- gcd$community_matrix
head(community_matrix)
```


## **Step 4.** `dco` performs differential community occupancy (DCO) analysis

```{r}
d <- dco(community_matrix = community_matrix,
         mcmc_control = list(mcmc_warmup = 500, 
                             mcmc_iter = 1500,
                             mcmc_chains = 3, 
                             mcmc_cores = 1, 
                             mcmc_algorithm = "NUTS",
                             adapt_delta = 0.9, 
                             max_treedepth = 10))
```



```{r, fig.width=6, fig.height=2.5}
ggplot(data = d$posterior_summary$y_hat)+
  facet_wrap(facets = ~sample, nrow = 1, scales = "free")+
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", col = "gray")+
  geom_errorbar(aes(x = y_obs, y = mean, ymin = X2.5., ymax = X97.5.), 
                col = "darkgray", width=0)+
  geom_point(aes(x = y_obs, y = mean), size = 0.8)+
  xlab(label = "observed y")+
  ylab(label = "predicted y (and 95% HDI)")+
  theme_bw(base_size = 10)
```



```{r, fig.width=6, fig.height=4}
beta <- d$posterior_summary$beta
beta$interesting <- ifelse(test = beta$X2.5.<=0 & beta$X97.5.>=0, 
                           yes = "-", no = "+")
ggplot(data = beta)+
  geom_errorbar(aes(x = community, y = mean, ymin = X2.5., ymax = X97.5., 
                    col = interesting), width =0)+
  geom_point(aes(x = community, y = mean), size = 0.5)+
  theme_bw(base_size = 10)+
  theme(legend.position = "none")+
  scale_color_manual(values = c("darkgray", "black"))+
  ylab(label = expression(beta))
```

Distribution of mean $\beta$s

```{r, fig.width=4, fig.height=3}
ggplot(data = d$posterior_summary$beta)+
  geom_histogram(aes(mean), bins = 100)+
  xlab(label = expression(beta))+
  theme_bw(base_size = 10)
```


```{r session_info}
utils::sessionInfo()
```


[^1]: Glanville, Jacob, et al. "Identifying specificity groups in the T cell 
receptor repertoire." Nature 547.7661 (2017): 94-98.
